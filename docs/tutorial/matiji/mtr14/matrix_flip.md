# 矩阵翻转

## 解题思路

结论题，将 `o` 视为 $0$，将 `X` 视为 $1$，在按行按列异或得到的数字中分别统计 $1$ 的个数取最大即得到答案。以下给出证明。

按照上述规则将给出的图案转换成 $01$ 矩阵后，不难发现每次操作相当于用矩阵 $\begin{bmatrix} 1 &1 \\ 1 &1 \end{bmatrix}$ 异或某一个位置。

首先可以注意到，求最少改变多少个位置让问题有解，可以等价为求进行若干次操作后，矩阵中可以得到的最少的 $1$ 的个数是多少。

考虑原矩阵分别按行按列异或得到的两个异或和，不难发现，每次操作均不会改变这两个异或和。因此我们可以断定进行任意多的操作后，对于按行异或和中的每一个 $1$，在原矩阵对应的列中必然有至少一个 $1$。类似地，对于按列异或和中的每一个 $1$，在原矩阵对应的行中必然有至少一个 $1$。于是要得到最少的 $1$ 的个数，可以对于按行/列异或和中每一个 $1$，寻找按列/行异或和中的另一个 $1$，并在原矩阵中由此确定的位置改为 $1$，其它的地方均为 $0$。语言组织不甚连贯，可以看图形象理解。

$$
\begin{matrix}
&0 &\ldots &0 &\ldots &0 &0 \\
&\vdots &\ddots &\vdots &\ddots &0 &0 \\
&0 &\ldots &1 &\ldots &0 &1 \\
&0 &\ldots &0 &\ldots &0 &0 \\
&\vdots &\ddots &\vdots &\ddots &0 &0 \\
&0 &\ldots &0 &\ldots &0 &0 \\
&0 &0 &1 &0 &0
\end{matrix}
$$

最下侧为按行异或和，最右侧为按列异或和。形式化地，分别记为 $S, T$。于是当且仅当 $T(i) = 1$ 且 $S(j) = 1$ 时，令原矩阵的元素 $M(i, j) = 1$，此时得到的 $1$ 的个数是最少的。也就是一开始给出的答案。

除了直接异或，也有其它的方法可以得到按行按列的异或和。我们按顺序遍历这个矩阵，对于每个的 $1$ 进行一次操作使它变为 $0$，并扩展矩阵边界防止出现不合法操作，那么最终会得到一个除了右边界与下边界都为 $0$ 的扩展矩阵。由于异或和不改变而其它地方都是 $0$，因此下边界和右边界即为按行和按列的异或和。

- Todo：证明对原矩阵直接遍历操作，统计边界取最大也能得到正确答案。

## 参考代码

```cpp
#include <iostream>
using namespace std;

const int MAXN = 810;
bool g[MAXN][MAXN];

int main()
{
#ifndef ONLINE_JUDGE
    freopen("./in", "r", stdin);
#endif
    ios_base::sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            char c;
            cin >> c;
            g[i][j] = (c == 'X');
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        bool t = false;
        for (int j = 1; j <= m; j++) {
            t ^= g[i][j];
        }
        ans += t;
    }
    int ans2 = 0;
    for (int j = 1; j <= m; j++) {
        bool t = false;
        for (int i = 1; i <= n; i++) {
            t ^= g[i][j];
        }
        ans2 += t;
    }
    cout << max(ans, ans2) << endl;
    return 0;
}
```