# UVA1309 Sudoku

## Solution

&emsp;&emsp;人生第一道独立写的黑题。（虽然剪枝思路有几个看了题解，而且好像是蓝书的例题

&emsp;&emsp;题意非常的简单，就是填完一个 $16 \times 16$ 的数独。（实现起来也非常 “简单”

&emsp;&emsp;我们考虑直接爆搜出奇迹。为了方便判断与操作，将每一位能填的数压成一个 $16$ 位二进制数。笔者采用了「$1$ 表示不能填，$0$ 表示能填」的策略。我们在每一阶段枚举当前位置能填的字母，逐层往下搜索，遇到可行解时即返回。

&emsp;&emsp;很显然状态数无法接受，这里最多会遍历 $16^{256}$ 种可能性，我们要做的就是通过剪枝把它剪到可以在 1 s 内跑完的规模。

&emsp;&emsp;为了实现爆搜出奇迹的信仰（什），我们要加入剪枝策略。

&emsp;&emsp;首先为了方便地遍历所有行、列、格对应的位置，我们可以将所有行、列、小格子和大格子编上号，并打表打出所有行内包含的格子的编号、所有格子所在行的编号，对于列和大格子我们执行类似的操作。这样，我们在某一格填入数字的时候，就可以方便地进行遍历操作。每层进行搜索时，我们将当前状态全部复制存储在另一个数组里，回溯时还原。

&emsp;&emsp;在此基础上，我们再进行如下剪枝：

- 枚举填数时，每次寻找可填的数最少的枚举。
- 在每一层遍历所有格，如果当前格仅有一个数可以填，直接填上。
- 遍历所有行、列、十六宫格，如果发现某个数仅可在一个位置填，直接填上。
- 检查填上枚举的数后是否有别的格子无数可填，如果有就回溯。

&emsp;&emsp;注意在加入这些剪枝后，我们需要备份两份状态，分别供某分支搜索失败回溯、当前函数搜索失败回溯时还原使用。

&emsp;&emsp;其实逻辑很简单，主要码量较大。

&emsp;&emsp;另外如果样例过了交 UVA 反而 Wrong Answer，并且提示 Presentation Error，那么其实你的代码大概率是没有大问题的，检查下输出格式，比如多了个空行啦什么的。这里会稍麻烦些，在这道题中，每组数据的答案间必须隔有一个空行，同时，输出末尾不能有超过一个空行，开头也不能有空行。这是比较烦人的地方。可以参考 AC 代码进行修改。

## Code

&emsp;&emsp;洛咕显示我的代码长度为 12.99 KB，但是本地是 12.6 KB，略删减些不必要的内容后还剩 12.5 KB。

&emsp;&emsp;好多人都跑的比我快欸，码量还比我少（哭

&emsp;&emsp;（这个代码长度简直是前无古人后无来者

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int row[16][16] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
    {32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47},
    {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63},
    {64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79},
    {80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95},
    {96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111},
    {112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127},
    {128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143},
    {144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159},
    {160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175},
    {176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191},
    {192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207},
    {208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223},
    {224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239},
    {240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
};

const int rid[256] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15
};

const int col[16][16] = {
    {0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240},
    {1, 17, 33, 49, 65, 81, 97, 113, 129, 145, 161, 177, 193, 209, 225, 241},
    {2, 18, 34, 50, 66, 82, 98, 114, 130, 146, 162, 178, 194, 210, 226, 242},
    {3, 19, 35, 51, 67, 83, 99, 115, 131, 147, 163, 179, 195, 211, 227, 243},
    {4, 20, 36, 52, 68, 84, 100, 116, 132, 148, 164, 180, 196, 212, 228, 244},
    {5, 21, 37, 53, 69, 85, 101, 117, 133, 149, 165, 181, 197, 213, 229, 245},
    {6, 22, 38, 54, 70, 86, 102, 118, 134, 150, 166, 182, 198, 214, 230, 246},
    {7, 23, 39, 55, 71, 87, 103, 119, 135, 151, 167, 183, 199, 215, 231, 247},
    {8, 24, 40, 56, 72, 88, 104, 120, 136, 152, 168, 184, 200, 216, 232, 248},
    {9, 25, 41, 57, 73, 89, 105, 121, 137, 153, 169, 185, 201, 217, 233, 249},
    {10, 26, 42, 58, 74, 90, 106, 122, 138, 154, 170, 186, 202, 218, 234, 250},
    {11, 27, 43, 59, 75, 91, 107, 123, 139, 155, 171, 187, 203, 219, 235, 251},
    {12, 28, 44, 60, 76, 92, 108, 124, 140, 156, 172, 188, 204, 220, 236, 252},
    {13, 29, 45, 61, 77, 93, 109, 125, 141, 157, 173, 189, 205, 221, 237, 253},
    {14, 30, 46, 62, 78, 94, 110, 126, 142, 158, 174, 190, 206, 222, 238, 254},
    {15, 31, 47, 63, 79, 95, 111, 127, 143, 159, 175, 191, 207, 223, 239, 255}
};

const int cid[256] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
};

const int sq[16][16] = {
    {0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51},
    {4, 5, 6, 7, 20, 21, 22, 23, 36, 37, 38, 39, 52, 53, 54, 55},
    {8, 9, 10, 11, 24, 25, 26, 27, 40, 41, 42, 43, 56, 57, 58, 59},
    {12, 13, 14, 15, 28, 29, 30, 31, 44, 45, 46, 47, 60, 61, 62, 63},
    {64, 65, 66, 67, 80, 81, 82, 83, 96, 97, 98, 99, 112, 113, 114, 115},
    {68, 69, 70, 71, 84, 85, 86, 87, 100, 101, 102, 103, 116, 117, 118, 119},
    {72, 73, 74, 75, 88, 89, 90, 91, 104, 105, 106, 107, 120, 121, 122, 123},
    {76, 77, 78, 79, 92, 93, 94, 95, 108, 109, 110, 111, 124, 125, 126, 127},
    {128, 129, 130, 131, 144, 145, 146, 147, 160, 161, 162, 163, 176, 177, 178, 179},
    {132, 133, 134, 135, 148, 149, 150, 151, 164, 165, 166, 167, 180, 181, 182, 183},
    {136, 137, 138, 139, 152, 153, 154, 155, 168, 169, 170, 171, 184, 185, 186, 187},
    {140, 141, 142, 143, 156, 157, 158, 159, 172, 173, 174, 175, 188, 189, 190, 191},
    {192, 193, 194, 195, 208, 209, 210, 211, 224, 225, 226, 227, 240, 241, 242, 243},
    {196, 197, 198, 199, 212, 213, 214, 215, 228, 229, 230, 231, 244, 245, 246, 247},
    {200, 201, 202, 203, 216, 217, 218, 219, 232, 233, 234, 235, 248, 249, 250, 251},
    {204, 205, 206, 207, 220, 221, 222, 223, 236, 237, 238, 239, 252, 253, 254, 255}
};

const int sid[256] = {
    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 
    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 
    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 
    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 
    4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 
    4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 
    4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 
    4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 
    8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 
    8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 
    8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 
    8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 
    12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 
    12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 
    12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 
    12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15
};

const unsigned DET = (1 << 16) - 1;

unsigned sta[256];
char ans[256];
int cnt;

inline void print()
{
    for (int i = 0; i < 256; i += 16) {
        for (int j = 0; j < 16; j++) {
            cout << ans[i + j];
        }
        cout << endl;
    }
}

inline int popcnt(int p)
{
    unsigned x = sta[p];
    int ans = 0;
    while (x) {
        ans++;
        x -= x & -x;
    }
    return ans;
}

inline void set(int x, int c)
{
    int p = rid[x];
    for (int i = 0; i < 16; i++) {
        sta[row[p][i]] |= 1UL << c;
    }
    p = cid[x];
    for (int i = 0; i < 16; i++) {
        sta[col[p][i]] |= 1UL << c;
    }
    p = sid[x];
    for (int i = 0; i < 16; i++) {
        sta[sq[p][i]] |= 1UL << c;
    }
}

inline int Find()
{
    int p = -1;
    for (int i = 0; i < 256; i++) {
        if (sta[i] == DET) continue;
        if (p == -1 || popcnt(i) > popcnt(p)) {
            p = i;
        }
    }
    return p;
}

inline bool fill()
{
    bool ret = false;
    for (int i = 0; i < 256; i++) {
        if (popcnt(i) == 15) {
            int c = 0;
            while (sta[i] & 1) {
                c++;
                sta[i] >>= 1;
            }
            sta[i] = DET;
            ans[i] = 'A' + c;
            set(i, c);
            cnt--;
            ret = true;
        }
    }
    for (int i = 0; i < 16; i++) {
        unsigned s = DET;
        for (int j = 0; j < 16; j++) {
            s &= sta[row[i][j]];
        }
        int c = 0;
        while (c < 16) {
            if (!(s & 1)) {
                int p = -1;
                bool flag = false;
                for (int j = 0; j < 16; j++) {
                    if ((sta[row[i][j]] >> c) & 1) continue;
                    if (p == -1) p = j, flag = true;
                    else {
                        flag = false;
                        break;
                    }
                }
                if (flag) {
                    sta[row[i][p]] = DET;
                    ans[row[i][p]] = 'A' + c;
                    set(row[i][p], c);
                    cnt--;
                    ret = true;
                }
            }
            s >>= 1;
            c++;
        }
    }
    for (int i = 0; i < 16; i++) {
        unsigned s = DET;
        for (int j = 0; j < 16; j++) {
            s &= sta[col[i][j]];
        }
        int c = 0;
        while (c < 16) {
            if (!(s & 1)) {
                int p = -1;
                bool flag = false;
                for (int j = 0; j < 16; j++) {
                    if ((sta[col[i][j]] >> c) & 1) continue;
                    if (p == -1) p = j, flag = true;
                    else {
                        flag = false;
                        break;
                    }
                }
                if (flag) {
                    sta[col[i][p]] = DET;
                    ans[col[i][p]] = 'A' + c;
                    set(col[i][p], c);
                    cnt--;
                    ret = true;
                }
            }
            s >>= 1;
            c++;
        }
    }
    for (int i = 0; i < 16; i++) {
        unsigned s = DET;
        for (int j = 0; j < 16; j++) {
            s &= sta[sq[i][j]];
        }
        int c = 0;
        while (c < 16) {
            if (!(s & 1)) {
                int p = -1;
                bool flag = false;
                for (int j = 0; j < 16; j++) {
                    if ((sta[sq[i][j]] >> c) & 1) continue;
                    if (p == -1) p = j, flag = true;
                    else {
                        flag = false;
                        break;
                    }
                }
                if (flag) {
                    sta[sq[i][p]] = DET;
                    ans[sq[i][p]] = 'A' + c;
                    set(sq[i][p], c);
                    cnt--;
                    ret = true;
                }
            }
            s >>= 1;
            c++;
        }
    }
    return ret;
}

unsigned bks[256][2][256];
char bka[256][2][256];

int num;

bool dfs(int now)
{
    num++;
    memcpy(bks[now][0], sta, sizeof sta);
    memcpy(bka[now][0], ans, sizeof ans);
    int bkc = cnt;

    fill();

    memcpy(bks[now][1], sta, sizeof sta);
    memcpy(bka[now][1], ans, sizeof ans);

    if (!cnt) {
        return true;
    }

    int p = Find();
    if (p == -1) {
        cnt = bkc;
        memcpy(sta, bks[now][0], sizeof sta);
        memcpy(ans, bka[now][0], sizeof ans);
        return false;
    }
    cnt--;
    for (int c = 0; c < 16; c++) {
        if ((sta[p] >> c) & 1) continue;
        ans[p] = 'A' + c;
        sta[p] = DET;
        set(p, c);

        for (int i = 0; i < 256; i++) {
            if (ans[i] == '-' && sta[i] == DET) {
                goto NEXT;
            }
        }

        if (dfs(now + 1)) return true;

        NEXT:
        memcpy(sta, bks[now][1], sizeof sta);
        memcpy(ans, bka[now][1], sizeof ans);
    }

    cnt = bkc;
    memcpy(sta, bks[now][0], sizeof sta);
    memcpy(ans, bka[now][0], sizeof ans);

    return false;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("in", "r", stdin);
    // freopen("out", "w", stdout);
#endif
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    const char endl = '\n';

    char t;
    bool u = false;
    while (cin >> t) {
        memset(sta, 0, sizeof sta);
        memset(ans, 0, sizeof ans);
        cnt = 0;
        if (u) {
            cout << endl;
        }
        u = true;

        for (int i = 0; i < 256; i++) {
            char c;
            if (i == 0) c = t;
            else cin >> c;
            if (c == '-') {
                ans[i] = '-';
                cnt++;
            }
            else {
                sta[i] = DET;
                ans[i] = c;
                set(i, c - 'A');
            }
        }

        dfs(0);

        for (int i = 0; i < 256; i += 16) {
            for (int j = 0; j < 16; j++) {
                cout << ans[i + j];
            }
            cout << endl;
        }
    }

    return 0;
}
```